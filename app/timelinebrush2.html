<!DOCTYPE html>
<meta charset="utf-8">
<style>


body{
    font-family: Arial,Helvetica Neue,Helvetica,sans-serif; 
    font size: 0.7em;
}
.area {
  clip-path: url(#clip);
}
.area-grey{
    fill: darkgrey;
}

.area-merging{
    fill: orange;
    
}

.area-platooning{
    fill: green;
    
}

.zoom {
  cursor: move;
  fill: none;
  pointer-events: all;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

path { 
    stroke: rgba(50,50,50, 0.05);
    stroke-width: 4;
    fill: none;
    pointer-events: visibleStroke;
}

#firstPanel{
    height:700px;
    padding-bottom: 5px;
    
}
#secondPanel{
    width:1200px;
    border:1px solid silver;
}

.mapOutline{
    /*stroke: rgba(50,50,50, 0.2);*/
    stroke:silver;
    stroke-width: 2;
    fill:none;
    /*fill: rgba(120,120,120, 0.05);   */
}
#map{
    display: block;
    float:left;
    top:10px;
    left:10px;
    height:700px;
    width:700px;
    border:1px solid silver;
     
}
#platoonPanel{
    display: block;
    float:left;
    top:10px;
    left:10px;
    margin-left: 5px;
    height:700px;
    width:493px;
    border:1px solid silver;
     
}
#platoonPanelContent{
    margin-left: 10px;
    margin-top: 10px;
    height:100%;
    width:100%;
}

.truckTrip{
    fill:darkgrey;
    
}
.platoonRect{
    fill:green;
    stroke: darkgreen;
    stroke-width: 2px;
}
.mergeRect{
    fill:orange;
    stroke: darkorange;
    stroke-width: 2px;
}

.hover-line{
    stroke-width:2px;
    stroke: steelblue;
    stroke-dasharray: 5

}
.hover-locked{
    stroke-width:5px;
    stroke: green;
}

.highlightCircle{
    stroke:darkgrey;
    fill:none;
    stroke-width: 2px;
}

#text-label{
    color: red;
}

.leader{
    stroke:green;
    stroke-width:2px;
}
.follower{
    stroke:orange;
    stroke-width:1px;
}

.merging{
    fill:orange;
}
.merged{
    fill:green;
}

#parameterDisplay{
    color: darkgrey;
    height:20px;
    width:1200px;
}
</style>
<div id="parameterDisplay">

</div>  
<div id="firstPanel">
    <div id="map" >
    </div>
    <div id="platoonPanel">
        <div id="platoonPanelContent">
        </div>
    </div>

</div>
<div id="secondPanel">
    <div id="timeline">
        <svg width="1200" height="300" ></svg>
    </div>
</div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
//console.time("calcs");
var truckData = 0;
var activeTrucks = [];
var maxTime =0;
var brushedTrucks =[];
var brushedTrucksLength = 0;
var selectedTrucks = [];
var mapCoords = [];
var currentMapTransform = -1;
var platoons = [];
var brushedPlatoons = [];
var currentMouseOverTruck = -1;
var currentTimeLineScrub = -1;
var currentNumberOfPlatooningTrucks = 0;
var currentNumberOfMergingTrucks = 0;
var currentSelectedTrucks = [];
var timeLineLock = 0;
var defaultPlanPlatooningTrucks = [];
var truckIdDict = {};

var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 110, left: 40},
    margin2 = {top: 230, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

//var parseDate = d3.timeParse("%b %Y");

var x = d3.scaleLinear().range([0, width]),
    x2 = d3.scaleLinear().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisLeft(y);

var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);

var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);

var area = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x(d.time); })
    .y0(height)
    .y1(function(d) { return y(d.total); });

var areaMerging = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x(d.time); })
    .y0(height)
    .y1(function(d) { return y(eval(d.merging + d.platooning)); });

var areaPlatooning = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x(d.time); })
    .y0(height)
    .y1(function(d) { return y(d.platooning); });

var area2 = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x2(d.time); })
    .y0(height2)
    .y1(function(d) { return y2(d.total); });

var bisectTime = d3.bisector(function(d) { return d.time; }).left;

svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var selectionCounterText = focus.append("text")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .attr("class", "text-label")
    .style("fill", "dimgrey");

var timeLineScrub = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .attr("class", "text-labe timeLineScrub")
    .style("fill", "dimgrey")
    .style("display", "none");
   
var line = d3.line()
    .x(function(d) { return x(d.time); })
    .y(function(d) { return y(d.total); });

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");


//d3.json("/data/outputTruncatedRoutes2.json", function(error, data1) {
//d3.json("/data/output1000.json", function(error, data1) {
d3.json("/data/output1000.json", function(error, data1) {
    if (error) throw error;
    
    // Load the map of sweden and draw it 
    d3.json("/data/svarje.json", function(error, data2){
        if (error) throw error;
        data2.coordinates.forEach(function(d){
            d.long = +d.long;
            d.lat = +d.lat;
        });
        
        mapCoords = data2;
        
        data1.trucks.forEach(function(d1){
            d1.route.forEach(function(d) {
                d.long = +d.long/1000000;
                d.lat = +d.lat/1000000;
            });
            d1.id = +d1.id;
            d1.start_time = +d1.start_time;
            d1.end_time = +d1.end_time;
            d1.deadline = +d1.deadline;
        });
        
        //console.time("calcs");
        truckData = data1;
        calculatePlatoons();
        calculateActiveTrucks();
        updateParameterDisplay();

        for(var index in truckData.trucks){
            var truck = truckData.trucks[index];
            var truckId = "t" + truck.id;
            truckIdDict[truckId] = truck;
        }
        
        var data = activeTrucks;

        x.domain(d3.extent(data, function(d) { return d.time; }));
        y.domain([0, d3.max(data, function(d) { return d.total; })]);
        x2.domain(x.domain());
        y2.domain(y.domain());

        //var focus = focusContainer.append("g");

        focus.append("path")
            .datum(data)
            .attr("class", "area area-grey")
            .attr("d", area);

        focus.append("path")
            .datum(data)
            .attr("class", "area area-merging")
            .attr("d", areaMerging);

        focus.append("path")
            .datum(data)
            .attr("class", "area area-platooning")
            .attr("d", areaPlatooning);

        focus.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        focus.append("g")
            .attr("class", "axis axis--y")
            .call(yAxis);

        context.append("path")
            .datum(data)
            .attr("class", "area-grey")
            .attr("d", area2);

        context.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + height2 + ")")
            .call(xAxis2);

        context.append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, x.range());

        timeLineScrub.append("line")
            .attr("transform", "translate("+ margin.left +","+ margin.top+")")
            .attr('class', 'x-hover-line hover-line')
            .attr('y1' , 0)
            .attr('y2', height);

        timeLineScrub.append("text")
            .attr("x", 45)
            .attr("y", 20)
            .attr("dy", ".2em");

        svg.append("rect")
            .attr("class", "zoom")
            .attr("width", width)
            .attr("height", height)
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .call(zoom)
            .on("mouseover",function(){
                //console.log(currentTimeLineScrub);
                if(timeLineLock == 0){
                    currentTimeLineScrub = -1;
                    timeLineScrub.style("display", null);
                    updateVis();
                }
            })
            .on("mouseout",function(){
                //console.log(currentTimeLineScrub);
                if(timeLineLock == 0){
                    currentTimeLineScrub = -1;
                    timeLineScrub.style("display", "none");
                    updateVis();
                }
            })
            .on("mousemove", function(){
                if(timeLineLock == 0){
                    var x0 = x.invert(d3.mouse(this)[0]),
                        i = bisectTime(data, x0, 1);
                        d0 = data[i - 1],
                        d1 = data[i],
                        d = x0 - d0.time > d1.time - x0 ? d1 : d0;
                    timeLineScrub.attr("transform", "translate(" + x(d.time) + ",0)");
                    timeLineScrub.select("text").text(d.total +" trucks at "+ d.time);
                    currentTimeLineScrub = d;
                    //console.log(currentTimeLineScrub);
                    updateVis();
                }
            })
            .on("click", function(){
                
                if(timeLineLock == 1){
                    timeLineLock = 0;
                }
                else{
                    timeLineLock = 1;
                    //timeLineScrub.attr("class", "rgba(0,0,9,0.5)");
                }
                //console.log(timeLineLock);
            });
      });
});





function updateMap(){
    var margin3 = {top: 30, right: 20, bottom: 30, left: 50};
    var width3 = 700 - margin3.left - margin3.right;
    var height3 = 700 - margin3.top - margin3.bottom;


    // Set the ranges
    var x3 = d3.scaleLinear().range([0, width3]);  
    var y3 = d3.scaleLinear().range([height3, 0]);

    // Define the line
    var pathline = d3.line()    
        .x(function(d) { return x3(d.long); })
        .y(function(d) { return y3(d.lat); });

    var outline = d3.line()    
        .x(function(d) { return x3(d.long); })
        .y(function(d) { return y3(d.lat); })
        .curve(d3.curveCardinal);

    var zoom = d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", mapZoomed);
        
    var nukeFromOrbit = d3.select("#map");
    nukeFromOrbit.html("");

    // Adds the svg canvas
    var mapView = d3.select("#map")
        .append("svg")
            .attr("width", width3 + margin3.left + margin3.right)
            .attr("height", height3 + margin3.top + margin3.bottom)
        .append("g")
            .attr("transform", 
                  "translate(" + margin3.left + "," + margin3.top + ")")
            .call(zoom);


    var rect = mapView.append("rect")
        .attr("width", width3)
        .attr("height", height3)
        .attr("class", ".mapZoomRect")
        .attr("transform", 
                  "translate(" + margin3.left + ")")
        .style("fill", "none")
        .style("pointer-events", "all");
        /*.call(d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", mapZoomed));*/

    //x3.domain(d3.extent(mapCoords.coordinates, function(d) { return d.long; }));
    //manually sets the x domain in order to have good aspect ratio even thoguh the data is scewed
    //x3.domain([9, 30]);
    //y3.domain(d3.extent(mapCoords.coordinates, function(d) { return d.lat; }));
    x3.domain([11,19]);
    y3.domain([55,60]);
    /*mapView.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(0," + height3 + ")")
        .call(d3.axisBottom(x3));

    // Add the Y Axis
    mapView.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y3));
*/

    var container = mapView.append("g");
    var paths = container.append("g")
        .attr("class", ".mapViewGroup");

    paths.append("path")
        .attr("class", "line")
        .attr("class", "mapOutline")
        .attr("d", outline(mapCoords.coordinates));

    if(currentTimeLineScrub != -1){

        currentNumberOfPlatooningTrucks = 0;
        currentNumberOfMergingTrucks = 0;
        truckDataAtTimeStep = currentTimeLineScrub.trucksAtTimestep;
        for(var truckIndex in truckDataAtTimeStep){
            var truck = truckDataAtTimeStep[truckIndex];
            //position it at the location in route that corresponds to the correct time
            // beware of the pos history not being correctly in sync with route due to truncation

            //TODO rework routepos to correct for speeeeed
            var time = currentTimeLineScrub.time;
            //var pathIndexAtScrub = calculatePathIndexAtTimeStep(truck, time);
            var pathIndexArray = calculatePathIndexAtTimeStep(truck, time);
            var t = pathIndexArray[1];
            var locationAtScrub = truck.route[pathIndexArray[0]];
            var interpolatedLong = locationAtScrub.long;
            var interpolatedLat = locationAtScrub.lat;
            
            if((parseInt(pathIndexArray[0]) + 1) <= truck.route.length ){
                interpolatedLong = ((1-t)*truck.route[parseInt(pathIndexArray[0])].long) + (t * locationAtScrub.long);
                interpolatedLat = ((1-t)*truck.route[parseInt(pathIndexArray[0])].lat) + (t * locationAtScrub.lat);
            }
            
            container.append("circle")
                        .attr("r", 5)
                        .attr("class", "highlightCircle")
                        //.attr("transform", "translate(" + x3(locationAtScrub.long) + "," + y3(locationAtScrub.lat) + ")")
                        .attr("transform", "translate(" + x3(interpolatedLong) + "," + y3(interpolatedLat) + ")")
                        .enter();
            if(typeof(truck.platooningLog) != 'undefined'){
                
                for(var sectionIndex in truck.platooningLog){
                    var section = truck.platooningLog[sectionIndex];
                    //if(truck.start_time + total_time*progress <= section.end_time && truck.start_time + total_time*progress >= section.start_time){
                    if(time < section.end_time && time >= section.start_time){
                        //console.log(section);
                        var platoonClass ="follower";
                        var leader = section.addedBy;
                        if(section.addedBy == "self"){
                            platoonClass = "leader";
                        }
                        if (section.plan.merge_distance != 0){
                            currentNumberOfMergingTrucks += 1;
                            container.append("circle")
                                .attr("r", 5)
                                .attr("class", "highlightCircle")
                                .attr("class", "merging " + platoonClass)
                                .attr("transform", "translate(" + x3(interpolatedLong) + "," + y3(interpolatedLat) + ")")
                                .on("mouseover", mapMouseOver)
                                .on("mouseout", mapMouseOut)//rework so it shows maybe correct colors, and working click functionalitey
                                .enter();
                                //Probably needs it's own functions to work correctly...

                                //TODO on hover the whole route plus platooning partner trucks should be highlighted for easier exploration
                                //TODO on click to add only selected trucks should be visible on timeline (try this, might be weird)
                                //TODO on mouse over the platoon path should be shown. needs data structure. at least go through platoonlog to loog into future. However the speed is done runtime.... hmmm think about it

                        }
                        if (section.plan.merge_distance == 0){
                            if(platoonClass == "leader"){

                                currentNumberOfPlatooningTrucks +=2;
                                container.append("circle")
                                    .attr("r", 8)
                                    //.attr("class", "highlightCircle")
                                    .attr("class", "merged " + platoonClass)
                                    .attr("transform", "translate(" + x3(interpolatedLong) + "," + y3(interpolatedLat) + ")")
                                    .on("mouseover", mapMouseOver)
                                    .on("mouseout", mapMouseOut)
                                    .enter(); 
                            }
                        }
                    }

                }
            }
        }
        
    }else{
        truckDataAtTimeStep = brushedTrucks;
    }

    // TODO show platooning parts of route for all paths
    // bisector times on timeline where truck is platooning
    // add seperate cases in the path drawing for these sections. 
    // draw grey standard path for non platooning sections. 
    //Append new group for each truck so all pgroups can be given an id and be joined to truck again.

    // simplest solution
    //go through platoonlog, for every section, calc what ratio that section has start an end time compared to total
    // paint that section with another color
    // does not show correct speeds, but is simpler and faster, could be reowrked later for correct view.

    for(var truckIndex in truckDataAtTimeStep){
        var truck = truckDataAtTimeStep[truckIndex];
        /*if(typeof(truck.platooningLog) != 'undefined'){
            for(var sectionIndex in truck.platooningLog){
                //section start_time how far along total time 
                var start = section.start_time - truck.start_time;
                var end = section.end_time - truck.start_time;
                //bisect all the routes.

            }

        }*/
        if(currentSelectedTrucks.includes((truck.id).toString())){

            paths.append("path")
                .attr("class", "line truckRoute")
                .attr("id", "t" + truck.id)
                .style("stroke","skyblue")
                .style("stroke-width","8")
                .attr("d", pathline(truck.route))
                .on("mouseover", mapMouseOver)
                .on("mouseout", mapMouseOut)
                .on("click", mapMouseClick);
        }else{

            paths.append("path")
                .attr("class", "line truckRoute")
                .attr("id", "t" + truck.id)
                .attr("d", pathline(truck.route))
                .on("mouseover", mapMouseOver)
                .on("mouseout", mapMouseOut)
                .on("click", mapMouseClick);
                //.style("stroke", "rgba(50,50,50, "+ 1/(0.1 *brushedTrucksLength)+")")
        }
    
    };
    
    mapView.append("text")
                .attr("x", - 20)
                .attr("y", height3)
                .attr("class", "text-label")
                .style("fill", "dimgrey");
    if(currentTimeLineScrub != -1){
        mapView.select("text").text(currentNumberOfPlatooningTrucks +" trucks are platooning. " + currentNumberOfMergingTrucks +" trucks are merging.");
    }

    var label = mapView.append("g");
    label.append("text")
                .attr("x", - 20)
                .attr("y", 20)
                .attr("class", "text-label-truck-id")
                .style("fill", "dimgrey");

    function mapMouseOver(){
        currentMouseOverTruck = d3.select(this)._groups[0][0].id.toString();
        //console.log(d3.select(this)._groups[0][0].id);
        label.select("text").text("Id: "+currentMouseOverTruck);
        d3.select(this)
            .transition()
            .duration(100)
            .style("stroke","royalblue")
            .style("stroke-width","10")
            .style("z-index", "10");


        
        if(typeof(truckIdDict[currentMouseOverTruck].platoonedWith) != 'undefined'){
            
            for(var relatedTruckIndex in truckIdDict[currentMouseOverTruck].platoonedWith){
                
                
                var id = "#t" + truckIdDict[currentMouseOverTruck].platoonedWith[relatedTruckIndex].id.toString();
                
                d3.select(id)
                    .transition()
                    .duration(100)
                    .style("stroke","red")
                    .style("stroke-width","8");
            }
        }
    }
    function mapMouseOut(){
        var mouseOutTruckId = d3.select(this)._groups[0][0].id.toString();
        if(typeof(truckIdDict[mouseOutTruckId].platoonedWith) != 'undefined'){
                
            for(var relatedTruckIndex in truckIdDict[mouseOutTruckId].platoonedWith){
                
                id = "#t" + truckIdDict[mouseOutTruckId].platoonedWith[relatedTruckIndex].id.toString();
                d3.select(id)
                    .transition()
                    .duration(100)
                    .style("stroke","rgba(50,50,0, 0.05)")
                    .style("stroke-width","4");
            }
        }
        currentMouseOverTruck = -1;
        if(currentSelectedTrucks.includes(mouseOutTruckId)){
            d3.select(this)
                .transition()
                .duration(100)
                .style("stroke","skyblue")
                .style("stroke-width","8")
                .style("z-index", "10");
        }else{
            //currentSelectedTrucks.push(clickedTruckId);
            d3.select(this)
                .transition()
                .duration(300)
                .style("stroke","rgba(50,50,0, 0.05)")
                .style("stroke-width","4");//it is style 
        }
        
    
    }
    function mapMouseClick(){
        clickedTruckId = d3.select(this)._groups[0][0].id;
        //console.log(d3.select(this));
        if(currentSelectedTrucks.includes(clickedTruckId)){
            currentSelectedTrucks.splice(currentSelectedTrucks.indexOf(clickedTruckId), 1)
        }else{
            currentSelectedTrucks.push(clickedTruckId);
        }
        updatePlatoonPanel();
        //console.log(currentSelectedTrucks);
    }

    //TODO Fix zoom behaviour to stop setting pos by brushing. very annoying
    function mapZoomed() {
        //console.log(currentMapTransform);
        //console.log(d3.event.transform);
        if(typeof(d3.event.transform) != 'undefined'){
            currentMapTransform = d3.event.transform;
        }
        container.attr("transform", currentMapTransform);
        //paths.attr("transform", d3.event.transform);
    }

    //if map is redrawn from brushing call mapzoomed to resume same transform
    if(currentMapTransform != -1 ){
        mapZoomed();   
    }
    /*if(typeof(d3.event.transform) != 'undefined'){
        currentMapTransform = d3.event.transform;
    }*/

};

function calculatePathIndexAtTimeStep(truck, time){
    
    var distanceTravelled = 0;
    var totalTravelTime = truck.deadline - truck.start_time; //truck total time ish 4h
    var progressedTime = (time - truck.start_time); // how far along this truck has been scrubbed
    var timeRemaining = progressedTime;
    var returnArray = []

    //console.log(truck.path_weights.length);
    //console.log(truck.route.length);


    for(var sh in truck.speed_history){
        var segment = truck.speed_history[sh];
        var segmentTime = segment.end_time - segment.start_time;
        if(timeRemaining > segmentTime){
            distanceTravelled += segment.speed * segmentTime;
            timeRemaining = timeRemaining - segmentTime;
        }else{
            distanceTravelled += segment.speed * timeRemaining;
            break
        }
    }


    //console.log(distanceTravelled);
    var sumWeights = 0;
    var finalPathProgress = 0; 
    for(var pathIndex in truck.path_weights){
        if(sumWeights < distanceTravelled && sumWeights + truck.path_weights[pathIndex] < distanceTravelled){
            sumWeights += truck.path_weights[pathIndex];


        }else if(sumWeights < distanceTravelled && sumWeights + truck.path_weights[pathIndex] > distanceTravelled){
            sumWeights += truck.path_weights[pathIndex]
            if(truck.path_weights[pathIndex] != 0){
                finalPathProgress = (sumWeights - distanceTravelled) / truck.path_weights[pathIndex];
                //console.log((sumWeights - distanceTravelled) / truck.path_weights[pathIndex]);
            }
            break

        }
        
    }
    
    returnArray.push(pathIndex);
    returnArray.push(finalPathProgress);
    return returnArray;

    //return truck.path_weights.length-1;
}

function calculateActiveTrucks(){
    var stepLength = 300;
    
    maxTime = d3.max(truckData.trucks, function(d){return d.deadline});
    steps = maxTime/stepLength;

    //sum up how many trucks are active at all times
    //ACTIVE TRUCKS contains the total amount and references to all trucks active att all time steps. 
    for(i=0;i<=steps;i++){
        var tick ={};
        tick.time = i*stepLength;
        tick.total = 0;
        tick.platooning = 0;
        tick.merging = 0;
        tick.trucksAtTimestep= [];
        for(var truckIndex in  truckData.trucks){
            var truck = truckData.trucks[truckIndex];
            if(tick.time <= truck.deadline && truck.start_time <= tick.time){
                tick.total ++;
                

                if(typeof(truck.platooningLog) != 'undefined'){
                
                    for(var sectionIndex in truck.platooningLog){
                        var section = truck.platooningLog[sectionIndex];
                        if(tick.time < section.end_time && tick.time >= section.start_time){
                            if(section.plan.merge_distance != 0){
                                tick.merging ++;
                            }
                            if(section.plan.merge_distance == 0){
                                tick.platooning ++;
                            }
                        }
                    }
                }
                tick.trucksAtTimestep.push(truck);
            }
        }
        activeTrucks.push(tick);
    }
    activeTrucks.push({"time": steps*stepLength, "total": 0, "merging": 0, "platooning": 0});
    //console.log(activeTrucks[activeTrucks.length-1]);
    
}

//Current state: every truck saves it's adapted plans into an array
function calculatePlatoons(){
    
    //system for finding trucks that do not have an adaptde plann, but still platooned.
    adaptedPlanTrucks = [];
    platooningTrucks = [];

    for(var truckIndex in truckData.trucks){
        var truck = truckData.trucks[truckIndex];

        if(truck.plan_history.length >1){
            var platoon = {};
            var thisTruckPlatoonedWith = [];

            for(var pIndex in truck.plan_history){
                var truckPlan = truck.plan_history[pIndex];
                if(truckPlan.plan[0].plan_type == "Adapted_plan"){
                    /*if(typeof(platoon[truck.id]) === 'undefined'){
                        platoon[truck.id] = 0;
                        thisTruckPlatoonedWith.push(truck);
                        adaptedPlanTrucks.push(truck.id);
                    }*/
                    for(var lead in truckData.trucks){
                        if(truckData.trucks[lead].id == truckPlan.plan[0].leader && typeof(platoon[truckData.trucks[lead].id]) === 'undefined'){
                            platoon[truckData.trucks[lead].id] = 0;
                            thisTruckPlatoonedWith.push(truckData.trucks[lead]);
                            platooningTrucks.push(truckData.trucks[lead].id);

                            //console.log(typeof(truckData.trucks[lead].platoonedWith) === 'undefined');
                            if(typeof(truckData.trucks[lead].platoonedWith) === 'undefined'){
                                truckData.trucks[lead].platoonedWith = [];
                                truckData.trucks[lead].platoonedWith.push(truck);
                            }else{
                                var idsInPlatoonedwith = []
                                for(var plw in truckData.trucks[lead].platoonedWith){
                                    idsInPlatoonedwith.push(truckData.trucks[lead].platoonedWith[plw].id);
                                }
                                if(!idsInPlatoonedwith.includes(truck.id)){
                                   
                                    truckData.trucks[lead].platoonedWith.push(truck);        
                                }   
                            //console.log(truckData.trucks[lead].platoonedWith);
                            }
                        }
                    }
                }   
            }
            truckData.trucks[truckIndex].platoonedWith = thisTruckPlatoonedWith;
        }
    }

    //finds ids of trucks that have no adapted plans but still platoon, yay.
    var defaultPlanPlatooners =[];

    //finds all trucks that has platooned but does not have an adapted plan and adds it's id to the array
    for(var i in platooningTrucks){
        if(!adaptedPlanTrucks.includes(platooningTrucks[i])){
            defaultPlanPlatooners.push(platooningTrucks[i]);
        }
    }
    //goes through the array of non-adaptedplan trucks and adds the whole object to array
    for(var t in truckData.trucks){
        if(defaultPlanPlatooners.includes(truckData.trucks[t].id)){
            //console.log(truckData.trucks[t]);
            defaultPlanPlatooningTrucks.push(truckData.trucks[t]);
        }
    }


    //find out when which truck has platooned with which.

    //loop through all trucks
    //find the adapted plans that corresponds to the event, string together timeline for each platoon
    //format in a sensical manner to browse platoons.
    for(var truckIndex in truckData.trucks){
        var truck = truckData.trucks[truckIndex];
        if(typeof(truck.platoonedWith) != 'undefined'){
            
            var platooningInstances = [];

            for(var pp in truck.platoonedWith){
                var platooningPartner = truck.platoonedWith[pp];
                //find plan with reference to this truck, could be this truck that follows as well. 
                //point is it doesn't matter who is leader that much
                for(var p in truck.plan_history){
                    var adaptedPlan = truck.plan_history[p];
                        
                    if(adaptedPlan.plan[0].plan_type == "Adapted_plan"){
                        
                        if(adaptedPlan.plan[0].leader == platooningPartner.id){
                            var platooningInstance = {};
                            platooningInstance.leader = platooningPartner;
                            platooningInstance.start_time = adaptedPlan.start_time;
                            platooningInstance.end_time = adaptedPlan.end_time;
                            platooningInstance.plan = adaptedPlan.plan[0];
                            platooningInstance.addedBy = "self";
                        
                            platooningInstances.push(platooningInstance);
                        }
                    }
                }
                for(var adp in platooningPartner.plan_history){
                    var ppAdp = platooningPartner.plan_history[adp];
                    if(ppAdp.plan[0].plan_type == 'Adapted_plan'){
                        
                        if(ppAdp.plan[0].leader == truck.id){

                            var partnerPlatooningInstance = {};
                            partnerPlatooningInstance.leader = truck;
                            partnerPlatooningInstance.start_time = ppAdp.start_time;
                            partnerPlatooningInstance.end_time = ppAdp.end_time;
                            partnerPlatooningInstance.plan = ppAdp.plan[0];
                            partnerPlatooningInstance.addedBy = platooningPartner.id;

                            platooningInstances.push(partnerPlatooningInstance);
                        }
                    }
                }
            }
            truckData.trucks[truckIndex].platooningLog = platooningInstances;
            //console.log(truck);
        }
    }
    


    
}

/*function updateList(){
    var truckList = d3.select("#brushedTrucksList");

    //console.log(brushedTrucks);
    brushedTrucks.sort((x,y) => x.id - y.id);
    truckList.html("");
    truckList.selectAll("li")
        .data(brushedTrucks.map(t => t.id))
        .enter()
        .append("li")
        .html(String);
}*/


function updatePlatoonPanel(){
    var truckList = d3.select("#platoonPanelContent");
    truckList.html("");
    //console.log(brushedTrucks);
    //brushedTrucks.sort((x,y) => x.id - y.id);


    var fullTruckData = [];
    for(var i in currentSelectedTrucks){
        fullTruckData.push(truckIdDict[currentSelectedTrucks[i]]);
    }
    
    var margin4 = {top: 30, right: 20, bottom: 30, left: 50};
    var width4 = 500 - margin4.left - margin4.right;
    var height4 = 700 - margin4.top - margin4.bottom;
    
    var trip = truckList.append("svg")
            .attr("width", width4 + margin4.left + margin4.right)
            .attr("height", height4 + margin4.top + margin4.bottom);

    var x4 = d3.scaleLinear().range([0, width4])  
        .domain([d3.min(fullTruckData, function(d){return d.start_time}), d3.max(fullTruckData, function(d){return d.deadline})]);
    
    
    //var y4 = d3.scaleLinear().range([height4, 0]);
    var y4 = d3.scaleLinear().range([height4, 0]).domain([0, height4]);
        


    /*for(var truckIndex in fullTruckData){
        var truck = fullTruckData[truckIndex];
        var div = truckList.append("div")
            .attr('pointer-events', 'none')
            .attr("class", "truck-detail label")
            .html("<p>Truck id: "+ truck.id + "<br> Start Time: " 
                +parseInt(truck.start_time) + ", End time: "+ parseInt(truck.deadline) +"</br></p>" );
        

        //TODO 
        //append a rect for every step of the trip, maybe star with one for the whole then overlay the platoon phases
        // set up scales and domain dynamically from the data OR make the whole panel scrollable in x-dir depending on what works best.
        //a standard trip and a selection of 2-3 platooning trucks SHOULD fit without much scrolling. 
        // Remember to think about no console usage = more space to work on
        //var detailGroup = div.append("g");
        //var travelRect = detailGroup.append("rect")
        //    .attr("x", )

    }*/
    
    var counter = 1;
    var yHeight = 30;
    var rectClass = "merge-rect";
    console.log(fullTruckData);
    trip.append("g")
        .selectAll(".truckTrip")
        .data(fullTruckData)
        .enter()
            .append("rect")
            .attr("class", "truckTrip")
            .attr("x", function(d,i){
                return x4(d.start_time)
            })
            .attr("y", eval(counter*yHeight))
            .attr("height", 20)/* function(d,i){
                return y4.bandwidth()-1;
            })*/
            .attr("width", function(d){
                return x4(d.deadline);
            })
            .enter();

    /*if(fullTruckData.length != 0){
        if(typeof(fullTruckData[0].platooningLog) != 'undefined'){
            console.log(fullTruckData[0].platooningLog[0]);
        trip.append("g")
            .selectAll(".platoonRect")
            .data([fullTruckData[0].platooningLog[0]])
            .enter()
                .append("rect")
                .attr("class", "platoonRect")
                .attr("x", function(d,i){
                    return x4(d.start_time)
                })
                .attr("y", eval(counter*yHeight))
                .attr("height", 20)
                .attr("width", function(d){
                    return x4(d.end_time);
                })
                .enter();
        }
    }*/
    for(var truckIndex in fullTruckData){
        var truck = fullTruckData[truckIndex];
        if(typeof(truck.platooningLog) != 'undefined'){
            //console.log("has log");
            for(var sectionIndex in truck.platooningLog){
                var section = truck.platooningLog[sectionIndex];
                //if(truck.start_time + total_time*progress <= section.end_time && truck.start_time + total_time*progress >= section.start_time){
                if(section.plan.merge_distance == 0){
                    console.log(section);
                    console.log(section.start_time);
                    console.log(section.end_time);
                    console.log(section.plan.merge_distance);

                    trip.append("g")
                        .selectAll(".platoonRect")
                        .data([section])
                        .enter()
                            .append("rect")
                            .attr("class", "platoonRect")
                            .attr("x", function(d,i){
                                return x4(d.start_time)
                            })
                            .attr("y", eval(counter*yHeight))
                            .attr("height", 20)
                            .attr("width", function(d){
                                return eval(x4(d.end_time) - x4(d.start_time));
                            })
                            .enter();

                }else{
                    trip.append("g")
                        .selectAll(".mergeRect")
                        .data([section])
                        .enter()
                            .append("rect")
                            .attr("class", "mergeRect")
                            .attr("x", function(d,i){
                                return x4(d.start_time)
                            })
                            .attr("y", eval(counter*yHeight))
                            .attr("height", 20)
                            .attr("width", function(d){
                                return eval(x4(d.end_time) - x4(d.start_time)-2);
                            })
                            .enter();
                }
            }
        }
    }

}

function updateParameterDisplay(){
    var parameters = d3.select("#parameterDisplay");
        parameters.html("");

        var div = parameters.append("div")
            .attr('pointer-events', 'none')
            .attr("class", "parameters-details label")
            .html("<p>Number of trucks: "+truckData.simulation_parameters.number_of_trucks +
                ", Recalculation interval: " + truckData.simulation_parameters.recalculation_interval +
                ", File name: "+ truckData.simulation_parameters.name +
                ", Clustering method: "+ truckData.simulation_parameters.clustering_method+ " </p>");

        //console.log("adding parameters");
}


function getBrushedTrucks(){
    brushedTrucks =[];
    selectedTrucks = [];
    var truckIDs = {};

    var left = parseInt((x.domain()[0]/maxTime)*activeTrucks.length);
    var right = parseInt((x.domain()[1]/maxTime)*activeTrucks.length);

    for(var i=left; i<right;i++){
        selectedTrucks.push(activeTrucks[i]);
    }
    if(typeof(selectedTrucks)!= 'undefined'){

        for(var timeStepIndex in selectedTrucks){
            var timeStep = selectedTrucks[timeStepIndex];

            for(var truckIndex in timeStep.trucksAtTimestep){
                var truck = timeStep.trucksAtTimestep[truckIndex];

                if(typeof(truckIDs[truck.id]) === 'undefined'){
                    truckIDs[truck.id] = 0;
                    brushedTrucks.push(truck);
                }
            }
        }
    }
    brushedTrucksLength = brushedTrucks.length;
    selectionCounterText.text(brushedTrucks.length + " out of "+ truckData.simulation_parameters.number_of_trucks);
    return brushedTrucks;
}

function brushed() {
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
    var s = d3.event.selection || x2.range();
    //console.log(s);
    x.domain(s.map(x2.invert, x2));
    focus.select(".area-grey").attr("d", area);
    focus.select(".area-merging").attr("d", areaMerging);
    focus.select(".area-platooning").attr("d", areaPlatooning);
    focus.select(".axis--x").call(xAxis);
    svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
        .scale(width / (s[1] - s[0]))
        .translate(-s[0], 0));

    brushedTrucks = getBrushedTrucks();
    updateVis();
    
}

function zoomed() {
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
    var t = d3.event.transform;
    x.domain(t.rescaleX(x2).domain());
    focus.select(".area-grey").attr("d", area);
    focus.select(".area-merging").attr("d", areaMerging);
    focus.select(".area-platooning").attr("d", areaPlatooning);
    focus.select(".axis--x").call(xAxis);
    context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
    //console.log(x.domain());

    brushedTrucks = getBrushedTrucks();
    //updateVis();


}
function updateVis(){
    //updateList();
    updatePlatoonPanel();
    updateMap();
}



</script>
