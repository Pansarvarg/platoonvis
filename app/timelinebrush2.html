<!DOCTYPE html>
<meta charset="utf-8">
<style>

.area {
  /*fill: silver;*/
  fill: silver;
  clip-path: url(#clip);
}

.zoom {
  cursor: move;
  fill: none;
  pointer-events: all;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

path { 
    stroke: rgba(50,50,50, 0.1);
    stroke-width: 4;
    fill: none;
    pointer-events: visibleStroke;
}

#firstPanel{
    height:700px;
    padding-bottom: 5px;
    
}
#secondPanel{
    width:1200px;
    border:1px solid silver;
}

.mapOutline{
    /*stroke: rgba(50,50,50, 0.2);*/
    stroke:silver;
    stroke-width: 2;
    fill:none;
    /*fill: rgba(120,120,120, 0.05);   */
}
#map{
    display: block;
    float:left;
    top:10px;
    left:10px;
    height:700px;
    width:700px;
    border:1px solid silver;
     
}
.hover-line{
    stroke-width:2px;
    stroke: steelblue;
    stroke-dasharray: 5

}
.highlightCircle{
    stroke:steelblue;
    fill:none;
    stroke-width: 1px;
}
/*ul{
    float:left;
    display: block;
    height:750px; 
    width:70px; 
    overflow-y:scroll;
    margin-top:0px;
    margin-bottom:0px;
}*/
</style>
<div id="firstPanel">
<!--    <div>
        <ul id="brushedTrucksList" ></ul>
    </div>
-->
    <div id="map" >
    </div>

</div>
<div id="secondPanel">
    <div id="timeline">
        <svg width="1200" height="300" ></svg>
    </div>
</div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var truckData = 0;
var activeTrucks = [];
var maxTime =0;
var brushedTrucks =[];
var selectedTrucks = [];
var mapCoords = [];
var currentMapTransform = -1;
var platoons = [];
var brushedPlatoons = [];
var currentMouseOverTruck = -1;
var currentTimeLineScrub = -1;
var timeLineLock = 0;
var defaultPlanPlatooningTrucks = [];

var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 110, left: 40},
    margin2 = {top: 230, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

//var parseDate = d3.timeParse("%b %Y");

var x = d3.scaleLinear().range([0, width]),
    x2 = d3.scaleLinear().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisLeft(y);

var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);

var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);

var area = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x(d.time); })
    .y0(height)
    .y1(function(d) { return y(d.total); });

var area2 = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x2(d.time); })
    .y0(height2)
    .y1(function(d) { return y2(d.total); });

var bisectTime = d3.bisector(function(d) { return d.time; }).left;

svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var timeLineScrub = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .attr("class", "timeLineScrub")
    .style("display", "none");
   
var line = d3.line()
    .x(function(d) { return x(d.time); })
    .y(function(d) { return y(d.total); });

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");


d3.json("/data/outputTruncatedRoutes.json", function(error, data1) {
    if (error) throw error;
    
    // Load the map of sweden and draw it 
    d3.json("/data/svarje.json", function(error, data2){
        if (error) throw error;
        data2.coordinates.forEach(function(d){
            d.long = +d.long;
            d.lat = +d.lat;
        });
        
        mapCoords = data2;
        
        data1.trucks.forEach(function(d1){
            d1.route.forEach(function(d) {
                d.long = +d.long/1000000;
                d.lat = +d.lat/1000000;
            });
            d1.id = +d1.id;
            d1.start_time = +d1.start_time;
            d1.end_time = +d1.end_time;
            d1.deadline = +d1.deadline;
        });
        
        
        truckData = data1;
        calculateActiveTrucks();
        calculatePlatoons();
        var data = activeTrucks;

        x.domain(d3.extent(data, function(d) { return d.time; }));
        y.domain([0, d3.max(data, function(d) { return d.total; })]);
        x2.domain(x.domain());
        y2.domain(y.domain());

        //var focus = focusContainer.append("g");

        focus.append("path")
            .datum(data)
            .attr("class", "area")
            .attr("d", area);

        focus.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        focus.append("g")
            .attr("class", "axis axis--y")
            .call(yAxis);

        context.append("path")
            .datum(data)
            .attr("class", "area")
            .attr("d", area2);

        context.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + height2 + ")")
            .call(xAxis2);

        context.append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, x.range());

        timeLineScrub.append("line")
            .attr("transform", "translate("+ margin.left +","+ margin.top+")")
            .attr('class', 'x-hover-line hover-line')
            .attr('y1' , 0)
            .attr('y2', height);

        timeLineScrub.append("text")
            .attr("x", 45)
            .attr("y", 20)
            .attr("dy", ".2em");

        svg.append("rect")
            .attr("class", "zoom")
            .attr("width", width)
            .attr("height", height)
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .call(zoom)
            .on("mouseover",function(){
                //console.log(currentTimeLineScrub);
                if(timeLineLock == 0){
                    currentTimeLineScrub = -1;
                    timeLineScrub.style("display", null);
                    updateVis();
                }
            })
            .on("mouseout",function(){
                //console.log(currentTimeLineScrub);
                if(timeLineLock == 0){
                    currentTimeLineScrub = -1;
                    timeLineScrub.style("display", "none");
                    updateVis();
                }
            })
            .on("mousemove", function(){
                if(timeLineLock == 0){
                    var x0 = x.invert(d3.mouse(this)[0]),
                        i = bisectTime(data, x0, 1);
                        d0 = data[i - 1],
                        d1 = data[i],
                        d = x0 - d0.time > d1.time - x0 ? d1 : d0;
                    timeLineScrub.attr("transform", "translate(" + x(d.time) + ",0)");
                    timeLineScrub.select("text").text(d.total +" trucks at "+ d.time);
                    currentTimeLineScrub = d;
                    //console.log(currentTimeLineScrub);
                    updateVis();
                }
            })
            .on("click", function(){
                
                if(timeLineLock == 1){
                    timeLineLock = 0;
                }
                else{
                    timeLineLock = 1;
                }
                //console.log(timeLineLock);
            });
      });
});

function updateDetails(){
    var margin4 = {top: 30, right: 20, bottom: 30, left: 50};
    var width3 = 300 - margin3.left - margin3.right;
    var height3 = 300 - margin3.top - margin3.bottom;

}

function updateMap(){
    var margin3 = {top: 30, right: 20, bottom: 30, left: 50};
    var width3 = 700 - margin3.left - margin3.right;
    var height3 = 700 - margin3.top - margin3.bottom;


    // Set the ranges
    var x3 = d3.scaleLinear().range([0, width3]);  
    var y3 = d3.scaleLinear().range([height3, 0]);

    // Define the line
    var pathline = d3.line()    
        .x(function(d) { return x3(d.long); })
        .y(function(d) { return y3(d.lat); });

    var outline = d3.line()    
        .x(function(d) { return x3(d.long); })
        .y(function(d) { return y3(d.lat); })
        .curve(d3.curveCardinal);

    var zoom = d3.zoom()
            .scaleExtent([1/3, 8])
            .on("zoom", mapZoomed);
        
    var nukeFromOrbit = d3.select("#map");
    nukeFromOrbit.html("");

    // Adds the svg canvas
    var mapView = d3.select("#map")
        .append("svg")
            .attr("width", width3 + margin3.left + margin3.right)
            .attr("height", height3 + margin3.top + margin3.bottom)
        .append("g")
            .attr("transform", 
                  "translate(" + margin3.left + "," + margin3.top + ")")
            .call(zoom);


    var rect = mapView.append("rect")
        .attr("width", width3)
        .attr("height", height3)
        .attr("class", ".mapZoomRect")
        .attr("transform", 
                  "translate(" + margin3.left + ")")
        .style("fill", "none")
        .style("pointer-events", "all");
        /*.call(d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", mapZoomed));*/

    //x3.domain(d3.extent(mapCoords.coordinates, function(d) { return d.long; }));
    //manually sets the x domain in order to have good aspect ratio even thoguh the data is scewed
    //x3.domain([9, 30]);
    //y3.domain(d3.extent(mapCoords.coordinates, function(d) { return d.lat; }));
    x3.domain([11,19]);
    y3.domain([55,60]);
    /*mapView.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(0," + height3 + ")")
        .call(d3.axisBottom(x3));

    // Add the Y Axis
    mapView.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y3));
*/

    var container = mapView.append("g");
    var paths = container.append("g")
        .attr("class", ".mapViewGroup");

    paths.append("path")
        .attr("class", "line")
        .attr("class", "mapOutline")
        .attr("d", outline(mapCoords.coordinates));

    if(currentTimeLineScrub != -1){
        truckDataAtTimeStep = currentTimeLineScrub.trucksAtTimestep;
        for(var truckIndex in truckDataAtTimeStep){
            var truck = truckDataAtTimeStep[truckIndex];
            //position it at the location in route that corresponds to the correct time
            // beware of the pos history not being correctly in sync with route due to truncation
            var total_time = truck.deadline - truck.start_time;
            var progress = (currentTimeLineScrub.time - truck.start_time)/ total_time;
            var locationAtScrub = truck.route[parseInt((truck.route.length-1)*progress)];
            

            //add visual indication of platooning trucks

            container.append("circle")
                .attr("r", 5)
                .attr("class", "highlightCircle")
                .attr("transform", "translate(" + x3(locationAtScrub.long) + "," + y3(locationAtScrub.lat) + ")")
                .enter();
        }
    }else{
        truckDataAtTimeStep = brushedTrucks;
    }
    truckDataAtTimeStep.forEach(function(d) { 
        //did = "#"+d.id;
        paths.append("path")
            .attr("class", "line")
            .attr("id", d.id)
            .attr("class", "truckRoute")
            .attr("d", pathline(d.route))
            .on("mouseover",function(d,i){
                currentMouseOverTruck = d3.select(this)._groups[0][0].id;
                //console.log(d3.select(this)._groups[0][0].id);
                d3.select(this)
                    .style("stroke","red")
                    .style("z-index", "10");//it is style 
           })
            .on("mouseout",function(d,i){
                currentMouseOverTruck = -1;
                d3.select(this)
                    .transition()
                    .duration(500)
                    .style("stroke","rgba(50,50,0, 0.2)");//it is style 
            });;     
    });

    //TODO Fix zoom behaviour to stop setting pos by brushing. very annoying
    function mapZoomed() {
        //console.log(currentMapTransform);
        //console.log(d3.event.transform);
        if(typeof(d3.event.transform) != 'undefined'){
            currentMapTransform = d3.event.transform;
        }
        container.attr("transform", currentMapTransform);
        //paths.attr("transform", d3.event.transform);
    }

    //if map is redrawn from brushing call mapzoomed to resume same transform
    if(currentMapTransform != -1 ){
        mapZoomed();   
    }
    /*if(typeof(d3.event.transform) != 'undefined'){
        currentMapTransform = d3.event.transform;
    }*/
};



function calculateActiveTrucks(){
    var stepLength = 300;
    
    maxTime = d3.max(truckData.trucks, function(d){return d.deadline});
    steps = maxTime/stepLength;

    //sum up how many trucks are active at all times
    //ACTIVE TRUCKS contains the total amount and references to all trucks active att all time steps. 
    for(i=0;i<=steps;i++){
        var tick ={};
        tick.time = i*stepLength;
        tick.total = 0;
        tick.trucksAtTimestep= [];
        for(var t=0;t< truckData.trucks.length; t++){
            if(tick.time <= truckData.trucks[t].deadline && truckData.trucks[t].start_time <= tick.time){
                tick.total ++;
                //lägg in lista med referenser istället.
                tick.trucksAtTimestep.push(truckData.trucks[t]);
            }
        }
        activeTrucks.push(tick);
    }
    activeTrucks.push({"time": steps*stepLength, "total": 0});
}

//Current state: every truck saves it's adapted plans into an array
function calculatePlatoons(){
    
    //system for finding trucks that do not have an adaptde plann, but still platooned.
    adaptedPlanTrucks = [];
    platooningTrucks = [];

    for(var truckIndex in truckData.trucks){
        var truck = truckData.trucks[truckIndex];

        if(truck.plan_history.length >1){
            var platoon = {};
            var thisTruckPlatoonedWith = [];

            for(var pIndex in truck.plan_history){
                var truckPlan = truck.plan_history[pIndex];
                if(truckPlan.plan[0].plan_type == "Adapted_plan"){
                    /*if(typeof(platoon[truck.id]) === 'undefined'){
                        platoon[truck.id] = 0;
                        thisTruckPlatoonedWith.push(truck);
                        adaptedPlanTrucks.push(truck.id);
                    }*/
                    for(var lead in truckData.trucks){
                        if(truckData.trucks[lead].id == truckPlan.plan[0].leader && typeof(platoon[truckData.trucks[lead].id]) === 'undefined'){
                            platoon[truckData.trucks[lead].id] = 0;
                            thisTruckPlatoonedWith.push(truckData.trucks[lead]);
                            platooningTrucks.push(truckData.trucks[lead].id);

                            //console.log(typeof(truckData.trucks[lead].platoonedWith) === 'undefined');
                            if(typeof(truckData.trucks[lead].platoonedWith) === 'undefined'){
                                truckData.trucks[lead].platoonedWith = [];
                                truckData.trucks[lead].platoonedWith.push(truck);
                            }else{
                                var idsInPlatoonedwith = []
                                for(var plw in truckData.trucks[lead].platoonedWith){
                                    idsInPlatoonedwith.push(truckData.trucks[lead].platoonedWith[plw].id);
                                }
                                if(!idsInPlatoonedwith.includes(truck.id)){
                                   
                                    truckData.trucks[lead].platoonedWith.push(truck);        
                                }   
                            //console.log(truckData.trucks[lead].platoonedWith);
                            }
                        }
                    }
                }   
            }
            truckData.trucks[truckIndex].platoonedWith = thisTruckPlatoonedWith;
        }
    }

    //finds ids of trucks that have no adapted plans but still platoon, yay.
    var defaultPlanPlatooners =[];

    //finds all trucks that has platooned but does not have an adapted plan and adds it's id to the array
    for(var i in platooningTrucks){
        if(!adaptedPlanTrucks.includes(platooningTrucks[i])){
            defaultPlanPlatooners.push(platooningTrucks[i]);
        }
    }
    //goes through the array of non-adaptedplan trucks and adds the whole object to array
    for(var t in truckData.trucks){
        if(defaultPlanPlatooners.includes(truckData.trucks[t].id)){
            //console.log(truckData.trucks[t]);
            defaultPlanPlatooningTrucks.push(truckData.trucks[t]);
        }
    }


    //find out when which truck has platooned with which.

    //loop through all trucks
    //find the adapted plans that corresponds to the event, string together timeline for each platoon
    //format in a sensical manner to browse platoons.
    for(var truckIndex in truckData.trucks){
        var truck = truckData.trucks[truckIndex];
        if(typeof(truck.platoonedWith) != 'undefined'){
            
            var platooningInstances = [];

            for(var pp in truck.platoonedWith){
                var platooningPartner = truck.platoonedWith[pp];
                //find plan with reference to this truck, could be this truck that follows as well. 
                //point is it doesn't matter who is leader that much
                for(var p in truck.plan_history){
                    var adaptedPlan = truck.plan_history[p];
                        
                    if(adaptedPlan.plan[0].plan_type == "Adapted_plan"){
                        
                        if(adaptedPlan.plan[0].leader == platooningPartner.id){
                            var platooningInstance = {};
                            platooningInstance.leader = platooningPartner;
                            platooningInstance.start_time = adaptedPlan.start_time;
                            platooningInstance.end_time = adaptedPlan.end_time;
                            platooningInstance.plan = adaptedPlan.plan[0];
                            platooningInstance.addedFrom = "self";
                        
                            platooningInstances.push(platooningInstance);
                        }
                    }
                }
                for(var adp in platooningPartner.plan_history){
                    var ppAdp = platooningPartner.plan_history[adp];
                    if(ppAdp.plan[0].plan_type == 'Adapted_plan'){
                        
                        if(ppAdp.plan[0].leader == truck.id){

                            var partnerPlatooningInstance = {};
                            partnerPlatooningInstance.leader = truck;
                            partnerPlatooningInstance.start_time = ppAdp.start_time;
                            partnerPlatooningInstance.end_time = ppAdp.end_time;
                            partnerPlatooningInstance.plan = ppAdp.plan[0];
                            partnerPlatooningInstance.addedBy = platooningPartner.id;

                            platooningInstances.push(partnerPlatooningInstance);
                        }
                    }
                }
            }
            truckData.trucks[truckIndex].platooningLog = platooningInstances;
            console.log(truck);
        }
    }
    


    
}

function updateList(){
    var truckList = d3.select("#brushedTrucksList");

    //console.log(brushedTrucks);
    brushedTrucks.sort((x,y) => x.id - y.id);
    truckList.html("");
    truckList.selectAll("li")
        .data(brushedTrucks.map(t => t.id))
        .enter()
        .append("li")
        .html(String);
}

function getBrushedTrucks(){
    brushedTrucks =[];
    selectedTrucks = [];
    var truckIDs = {};

    var left = parseInt((x.domain()[0]/maxTime)*activeTrucks.length);
    var right = parseInt((x.domain()[1]/maxTime)*activeTrucks.length);

    for(var i=left; i<right;i++){
        selectedTrucks.push(activeTrucks[i]);
    }
    if(typeof(selectedTrucks)!= 'undefined'){

        for(var timeStepIndex in selectedTrucks){
            var timeStep = selectedTrucks[timeStepIndex];

            for(var truckIndex in timeStep.trucksAtTimestep){
                var truck = timeStep.trucksAtTimestep[truckIndex];

                if(typeof(truckIDs[truck.id]) === 'undefined'){
                    truckIDs[truck.id] = 0;
                    brushedTrucks.push(truck);
                }
            }
        }
    }
    return brushedTrucks;
}

function brushed() {
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
    var s = d3.event.selection || x2.range();
    //console.log(s);
    x.domain(s.map(x2.invert, x2));
    focus.select(".area").attr("d", area);
    focus.select(".axis--x").call(xAxis);
    svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
        .scale(width / (s[1] - s[0]))
        .translate(-s[0], 0));

    brushedTrucks = getBrushedTrucks();
    updateVis();
    
}

function zoomed() {
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
    var t = d3.event.transform;
    x.domain(t.rescaleX(x2).domain());
    focus.select(".area").attr("d", area);
    focus.select(".axis--x").call(xAxis);
    context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
    //console.log(x.domain());

    brushedTrucks = getBrushedTrucks();
    updateVis();


}
function updateVis(){
    //updateList();
    updateMap();
}

      /*function type(d) {
        d.date = parseDate(d.date);
        d.price = +d.price;
        return d;
    }*/


</script>
